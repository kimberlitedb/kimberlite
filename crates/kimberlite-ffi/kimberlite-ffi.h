#ifndef KIMBERLITE_FFI_H
#define KIMBERLITE_FFI_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/*
 Error codes returned by all FFI functions.

 Error code 0 (`KMB_OK`) indicates success.
 All other codes indicate various failure modes.
 */
typedef enum kmb_KmbError {
    /*
     Success (no error)
     */
    KMB_KMB_ERROR_KMB_OK = 0,
    /*
     NULL pointer passed where non-NULL required
     */
    KMB_KMB_ERROR_KMB_ERR_NULL_POINTER = 1,
    /*
     String is not valid UTF-8
     */
    KMB_KMB_ERROR_KMB_ERR_INVALID_UTF8 = 2,
    /*
     Failed to connect to server
     */
    KMB_KMB_ERROR_KMB_ERR_CONNECTION_FAILED = 3,
    /*
     Stream ID does not exist
     */
    KMB_KMB_ERROR_KMB_ERR_STREAM_NOT_FOUND = 4,
    /*
     Operation not permitted for this tenant
     */
    KMB_KMB_ERROR_KMB_ERR_PERMISSION_DENIED = 5,
    /*
     Invalid data class value
     */
    KMB_KMB_ERROR_KMB_ERR_INVALID_DATA_CLASS = 6,
    /*
     Offset is beyond stream end
     */
    KMB_KMB_ERROR_KMB_ERR_OFFSET_OUT_OF_RANGE = 7,
    /*
     SQL syntax error
     */
    KMB_KMB_ERROR_KMB_ERR_QUERY_SYNTAX = 8,
    /*
     Query execution error
     */
    KMB_KMB_ERROR_KMB_ERR_QUERY_EXECUTION = 9,
    /*
     Tenant ID does not exist
     */
    KMB_KMB_ERROR_KMB_ERR_TENANT_NOT_FOUND = 10,
    /*
     Authentication failed
     */
    KMB_KMB_ERROR_KMB_ERR_AUTH_FAILED = 11,
    /*
     Operation timed out
     */
    KMB_KMB_ERROR_KMB_ERR_TIMEOUT = 12,
    /*
     Internal server error
     */
    KMB_KMB_ERROR_KMB_ERR_INTERNAL = 13,
    /*
     No cluster replicas available
     */
    KMB_KMB_ERROR_KMB_ERR_CLUSTER_UNAVAILABLE = 14,
    /*
     Unknown error
     */
    KMB_KMB_ERROR_KMB_ERR_UNKNOWN = 15,
} kmb_KmbError;

/*
 Data classification for streams.
 */
typedef enum kmb_KmbDataClass {
    /*
     Protected Health Information (HIPAA-regulated)
     */
    KMB_KMB_DATA_CLASS_KMB_DATA_CLASS_PHI = 0,
    /*
     Non-PHI data
     */
    KMB_KMB_DATA_CLASS_KMB_DATA_CLASS_NON_PHI = 1,
    /*
     De-identified data
     */
    KMB_KMB_DATA_CLASS_KMB_DATA_CLASS_DEIDENTIFIED = 2,
} kmb_KmbDataClass;

/*
 Query parameter type.
 */
typedef enum kmb_KmbQueryParamType {
    /*
     Null value
     */
    KMB_KMB_QUERY_PARAM_TYPE_KMB_PARAM_NULL = 0,
    /*
     64-bit integer
     */
    KMB_KMB_QUERY_PARAM_TYPE_KMB_PARAM_BIG_INT = 1,
    /*
     Text string
     */
    KMB_KMB_QUERY_PARAM_TYPE_KMB_PARAM_TEXT = 2,
    /*
     Boolean
     */
    KMB_KMB_QUERY_PARAM_TYPE_KMB_PARAM_BOOLEAN = 3,
    /*
     Timestamp (nanoseconds since epoch)
     */
    KMB_KMB_QUERY_PARAM_TYPE_KMB_PARAM_TIMESTAMP = 4,
} kmb_KmbQueryParamType;

/*
 Query value type (output from query).
 */
typedef enum kmb_KmbQueryValueType {
    /*
     Null value
     */
    KMB_KMB_QUERY_VALUE_TYPE_KMB_VALUE_NULL = 0,
    /*
     64-bit integer
     */
    KMB_KMB_QUERY_VALUE_TYPE_KMB_VALUE_BIG_INT = 1,
    /*
     Text string
     */
    KMB_KMB_QUERY_VALUE_TYPE_KMB_VALUE_TEXT = 2,
    /*
     Boolean
     */
    KMB_KMB_QUERY_VALUE_TYPE_KMB_VALUE_BOOLEAN = 3,
    /*
     Timestamp (nanoseconds since epoch)
     */
    KMB_KMB_QUERY_VALUE_TYPE_KMB_VALUE_TIMESTAMP = 4,
} kmb_KmbQueryValueType;

/*
 Client connection configuration.
 */
typedef struct kmb_KmbClientConfig {
    /*
     Array of "host:port" strings (NULL-terminated)
     */
    const char *const *addresses;
    /*
     Number of addresses
     */
    uintptr_t address_count;
    /*
     Tenant ID
     */
    uint64_t tenant_id;
    /*
     Authentication token (NULL-terminated, may be empty)
     */
    const char *auth_token;
    /*
     Client name (e.g., "kimberlite-python")
     */
    const char *client_name;
    /*
     Client version (e.g., "0.1.0")
     */
    const char *client_version;
} kmb_KmbClientConfig;

/*
 Opaque handle to a client connection.

 Created by `kmb_client_connect()`, freed by `kmb_client_disconnect()`.
 */
typedef struct kmb_KmbClient {
    uint8_t _private[0];
} kmb_KmbClient;

/*
 Result from read_events operation.
 */
typedef struct kmb_KmbReadResult {
    /*
     Array of event data pointers
     */
    uint8_t **events;
    /*
     Parallel array of event lengths
     */
    uintptr_t *event_lengths;
    /*
     Number of events
     */
    uintptr_t event_count;
} kmb_KmbReadResult;

/*
 Query parameter value (input to query).
 */
typedef struct kmb_KmbQueryParam {
    /*
     Parameter type
     */
    enum kmb_KmbQueryParamType param_type;
    /*
     BigInt value (used when param_type == KmbParamBigInt)
     */
    int64_t bigint_val;
    /*
     Text value (NULL-terminated, used when param_type == KmbParamText)
     */
    const char *text_val;
    /*
     Boolean value (used when param_type == KmbParamBoolean)
     */
    int bool_val;
    /*
     Timestamp value (used when param_type == KmbParamTimestamp)
     */
    int64_t timestamp_val;
} kmb_KmbQueryParam;

/*
 Query value (output from query).
 */
typedef struct kmb_KmbQueryValue {
    /*
     Value type
     */
    enum kmb_KmbQueryValueType value_type;
    /*
     BigInt value (used when value_type == KmbValueBigInt)
     */
    int64_t bigint_val;
    /*
     Text value (NULL-terminated, owned by result, used when value_type == KmbValueText)
     */
    char *text_val;
    /*
     Boolean value (used when value_type == KmbValueBoolean)
     */
    int bool_val;
    /*
     Timestamp value (used when value_type == KmbValueTimestamp)
     */
    int64_t timestamp_val;
} kmb_KmbQueryValue;

/*
 Query result (2D array of values).
 */
typedef struct kmb_KmbQueryResult {
    /*
     Array of column names (NULL-terminated C strings, owned by result)
     */
    char **columns;
    /*
     Number of columns
     */
    uintptr_t column_count;
    /*
     Array of rows (each row is an array of KmbQueryValue)
     */
    struct kmb_KmbQueryValue **rows;
    /*
     Array of row lengths (number of values in each row)
     */
    uintptr_t *row_lengths;
    /*
     Number of rows
     */
    uintptr_t row_count;
} kmb_KmbQueryResult;

/*
 Connect to Kimberlite cluster.

 # Arguments
 - `config`: Connection configuration
 - `client_out`: Output parameter for client handle

 # Returns
 - `KMB_OK` on success
 - Error code on failure

 # Safety
 - `config` must be valid
 - All string pointers in config must be valid NULL-terminated C strings
 - Caller must call `kmb_client_disconnect()` to free client
 */
enum kmb_KmbError kmb_client_connect(const struct kmb_KmbClientConfig *config,
                                     struct kmb_KmbClient **client_out);

/*
 Disconnect from cluster and free client.

 # Arguments
 - `client`: Client handle from `kmb_client_connect()`

 # Safety
 - `client` must be a valid handle from `kmb_client_connect()`
 - After this call, `client` is invalid and must not be used
 */
void kmb_client_disconnect(struct kmb_KmbClient *client);

/*
 Create a new stream.

 # Arguments
 - `client`: Client handle
 - `name`: Stream name (NULL-terminated UTF-8)
 - `data_class`: Data classification
 - `stream_id_out`: Output parameter for stream ID

 # Returns
 - `KMB_OK` on success
 - Error code on failure

 # Safety
 - `client` must be valid
 - `name` must be valid NULL-terminated UTF-8 string
 - `stream_id_out` must be valid pointer
 */
enum kmb_KmbError kmb_client_create_stream(struct kmb_KmbClient *client,
                                           const char *name,
                                           enum kmb_KmbDataClass data_class,
                                           uint64_t *stream_id_out);

/*
 Append events to a stream.

 # Arguments
 - `client`: Client handle
 - `stream_id`: Stream ID
 - `expected_offset`: Expected current stream offset (optimistic concurrency)
 - `events`: Array of byte buffers
 - `event_lengths`: Parallel array of buffer lengths
 - `event_count`: Number of events
 - `first_offset_out`: Output parameter for first offset

 # Returns
 - `KMB_OK` on success
 - Error code on failure

 # Safety
 - `client` must be valid
 - `events` must be array of `event_count` valid pointers
 - `event_lengths` must be array of `event_count` lengths
 - `first_offset_out` must be valid pointer
 */
enum kmb_KmbError kmb_client_append(struct kmb_KmbClient *client,
                                    uint64_t stream_id,
                                    uint64_t expected_offset,
                                    const uint8_t *const *events,
                                    const uintptr_t *event_lengths,
                                    uintptr_t event_count,
                                    uint64_t *first_offset_out);

/*
 Read events from a stream.

 # Arguments
 - `client`: Client handle
 - `stream_id`: Stream ID
 - `from_offset`: Starting offset
 - `max_bytes`: Maximum bytes to read
 - `result_out`: Output parameter for read result

 # Returns
 - `KMB_OK` on success
 - Error code on failure

 # Safety
 - `client` must be valid
 - `result_out` must be valid pointer
 - Caller must call `kmb_read_result_free()` to free result
 */
enum kmb_KmbError kmb_client_read_events(struct kmb_KmbClient *client,
                                         uint64_t stream_id,
                                         uint64_t from_offset,
                                         uint64_t max_bytes,
                                         struct kmb_KmbReadResult **result_out);

/*
 Free read result.

 # Arguments
 - `result`: Result from `kmb_client_read_events()`

 # Safety
 - `result` must be a valid result from `kmb_client_read_events()`
 - After this call, `result` is invalid and must not be used
 */
void kmb_read_result_free(struct kmb_KmbReadResult *result);

/*
 Execute a SQL query against current state.

 # Arguments
 - `client`: Client handle
 - `sql`: SQL query string (NULL-terminated UTF-8)
 - `params`: Array of query parameters (may be NULL if param_count == 0)
 - `param_count`: Number of parameters
 - `result_out`: Output parameter for query result

 # Returns
 - `KMB_OK` on success
 - Error code on failure

 # Safety
 - `client` must be valid
 - `sql` must be valid NULL-terminated UTF-8 string
 - `params` must be array of `param_count` valid parameters (or NULL if param_count == 0)
 - `result_out` must be valid pointer
 - Caller must call `kmb_query_result_free()` to free result
 */
enum kmb_KmbError kmb_client_query(struct kmb_KmbClient *client,
                                   const char *sql,
                                   const struct kmb_KmbQueryParam *params,
                                   uintptr_t param_count,
                                   struct kmb_KmbQueryResult **result_out);

/*
 Execute a SQL query at a specific log position (point-in-time query).

 # Arguments
 - `client`: Client handle
 - `sql`: SQL query string (NULL-terminated UTF-8)
 - `params`: Array of query parameters (may be NULL if param_count == 0)
 - `param_count`: Number of parameters
 - `position`: Log position (offset) to query at
 - `result_out`: Output parameter for query result

 # Returns
 - `KMB_OK` on success
 - Error code on failure

 # Safety
 - `client` must be valid
 - `sql` must be valid NULL-terminated UTF-8 string
 - `params` must be array of `param_count` valid parameters (or NULL if param_count == 0)
 - `result_out` must be valid pointer
 - Caller must call `kmb_query_result_free()` to free result
 */
enum kmb_KmbError kmb_client_query_at(struct kmb_KmbClient *client,
                                      const char *sql,
                                      const struct kmb_KmbQueryParam *params,
                                      uintptr_t param_count,
                                      uint64_t position,
                                      struct kmb_KmbQueryResult **result_out);

/*
 Free query result.

 # Arguments
 - `result`: Result from `kmb_client_query()` or `kmb_client_query_at()`

 # Safety
 - `result` must be a valid result from `kmb_client_query()` or `kmb_client_query_at()`
 - After this call, `result` is invalid and must not be used
 */
void kmb_query_result_free(struct kmb_KmbQueryResult *result);

/*
 Get human-readable error message for error code.

 # Arguments
 - `error`: Error code

 # Returns
 - Static NULL-terminated string (do not free)

 # Safety
 - Always safe to call
 - Returned string is valid for lifetime of program
 */
const char *kmb_error_message(enum kmb_KmbError error);

/*
 Check if an error code indicates a retryable failure.

 # Arguments
 - `error`: Error code

 # Returns
 - 1 if retryable, 0 otherwise

 # Safety
 - Always safe to call
 */
int kmb_error_is_retryable(enum kmb_KmbError error);

#endif  /* KIMBERLITE_FFI_H */
