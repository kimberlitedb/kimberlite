#lang ivy1.7

# Kimberlite Viewstamped Replication with Byzantine Faults
#
# This specification models VSR consensus in the presence of Byzantine
# (malicious) replicas. Up to f replicas can be Byzantine.
#
# Verified Properties:
# - Agreement: honest replicas never commit conflicting commands
# - Log consistency: honest replicas have unique log entries per slot
# - Quorum intersection ensures safety despite Byzantine faults
#
# Modeling approach: Abstract quorum type with intersection axiom
# (standard Ivy pattern from Padon et al., "Paxos Made EPR")

################################################################################
# Type Definitions

type replica
type view
type opnum
type command
type quorum

# Interpret types as bounded integers for model checking
interpret replica -> bv[3]
interpret view -> bv[4]
interpret opnum -> bv[6]

################################################################################
# Byzantine Fault Model

relation byzantine(R:replica)
relation honest(R:replica)
axiom forall R:replica. honest(R) <-> ~byzantine(R)

################################################################################
# Quorum Configuration

# Quorum membership (abstract)
relation member(Q:quorum, R:replica)

# Any two quorums intersect in at least one honest replica (f < n/3)
axiom forall Q1:quorum, Q2:quorum.
    exists R:replica. member(Q1, R) & member(Q2, R) & honest(R)

################################################################################
# Leader Assignment (fixed, unique per view)

relation is_leader(R:replica, V:view)

# Each view has at most one leader
axiom forall V:view, R1:replica, R2:replica.
    is_leader(R1, V) & is_leader(R2, V) -> R1 = R2

################################################################################
# Protocol State

relation current_view(R:replica, V:view)
individual op_number(R:replica): opnum
individual commit_number(R:replica): opnum

relation log_entry(R:replica, O:opnum, V:view, C:command)

relation prepare_sent(R:replica, V:view, O:opnum, C:command)
relation prepare_ok_sent(R:replica, V:view, O:opnum)
relation commit_sent(R:replica, V:view, O:opnum)

relation committed(R:replica, V:view, O:opnum, C:command)
relation commit_quorum(R:replica, V:view, O:opnum, Q:quorum)

################################################################################
# Initial State

after init {
    current_view(R, V) := V = 0;
    op_number(R) := 0;
    commit_number(R) := 0;
    log_entry(R, O, V, C) := false;
    prepare_sent(R, V, O, C) := false;
    prepare_ok_sent(R, V, O) := false;
    commit_sent(R, V, O) := false;
    committed(R, V, O, C) := false;
    commit_quorum(R, V, O, Q) := false;
}

################################################################################
# Honest Replica Actions

action honest_leader_prepare(r:replica, v:view, o:opnum, c:command) = {
    require honest(r);
    require is_leader(r, v);
    require current_view(r, v);
    require o = op_number(r) + 1;
    require o > op_number(r);       # prevent bitvector overflow (63+1=0)

    prepare_sent(r, v, o, c) := true;
    log_entry(r, o, v, c) := true;
    op_number(r) := o;
}

action honest_follower_on_prepare(r:replica, sender:replica,
                                   v:view, o:opnum, c:command) = {
    require honest(r);
    require ~is_leader(r, v);
    require current_view(r, v);
    require is_leader(sender, v);   # verify prepare came from view leader
    require prepare_sent(sender, v, o, c);
    require o = op_number(r) + 1;
    require o > op_number(r);       # prevent bitvector overflow (63+1=0)

    log_entry(r, o, v, c) := true;
    op_number(r) := o;
    prepare_ok_sent(r, v, o) := true;
}

action honest_leader_commit(r:replica, v:view, o:opnum, c:command, q:quorum) = {
    require honest(r);
    require is_leader(r, v);
    require current_view(r, v);
    require log_entry(r, o, v, c);
    require o > commit_number(r);
    require forall R:replica. member(q, R) -> (prepare_ok_sent(R, v, o) | R = r);

    commit_number(r) := o;
    committed(r, v, o, c) := true;
    commit_sent(r, v, o) := true;
    commit_quorum(r, v, o, q) := true;
}

action honest_follower_on_commit(r:replica, leader_r:replica,
                                  v:view, o:opnum, c:command) = {
    require honest(r);
    require ~is_leader(r, v);       # leaders commit via honest_leader_commit
    require commit_sent(leader_r, v, o);
    require current_view(r, v);
    require o <= op_number(r);
    require o > commit_number(r);
    require log_entry(r, o, v, c);

    commit_number(r) := o;
    committed(r, v, o, c) := true;
}

################################################################################
# Byzantine Replica Actions

action byzantine_equivocate_prepare(r:replica, v:view, o:opnum,
                                      c1:command, c2:command) = {
    require byzantine(r);
    require c1 ~= c2;
    prepare_sent(r, v, o, c1) := true;
    prepare_sent(r, v, o, c2) := true;
}

action byzantine_fake_prepare_ok(r:replica, v:view, o:opnum) = {
    require byzantine(r);
    prepare_ok_sent(r, v, o) := true;
}

################################################################################
# Supporting Invariants (needed for inductive proof of agreement)

# 1. Honest replicas don't have log entries beyond their op_number
invariant [no_future_log]
    forall R:replica, O:opnum, V:view, C:command.
        honest(R) & log_entry(R, O, V, C) -> O <= op_number(R)

# 2. Log consistency: honest replica has unique command per (opnum, view)
invariant [log_consistency]
    forall R:replica, O:opnum, V:view, C1:command, C2:command.
        honest(R) & log_entry(R, O, V, C1) & log_entry(R, O, V, C2)
        -> C1 = C2

# 3. Honest prepare_ok implies a log entry exists
invariant [honest_prepare_ok_has_log]
    forall R:replica, V:view, O:opnum.
        honest(R) & prepare_ok_sent(R, V, O) ->
        exists C:command. log_entry(R, O, V, C)

# 4. Honest leader's log entry matches its prepare
invariant [leader_log_matches_prepare]
    forall R:replica, V:view, O:opnum, C:command.
        honest(R) & is_leader(R, V) & log_entry(R, O, V, C) ->
        prepare_sent(R, V, O, C)

# 5. Honest leader's prepare implies a log entry (converse of #4)
invariant [leader_prepare_implies_log]
    forall R:replica, V:view, O:opnum, C:command.
        honest(R) & is_leader(R, V) & prepare_sent(R, V, O, C) ->
        log_entry(R, O, V, C)

# 6. Honest follower's log entry came from the view leader's prepare
invariant [follower_log_from_leader]
    forall R:replica, V:view, O:opnum, C:command.
        honest(R) & ~is_leader(R, V) & log_entry(R, O, V, C) ->
        exists S:replica. is_leader(S, V) & prepare_sent(S, V, O, C)

# 7. Honest leader only prepares unique command per (view, opnum)
invariant [leader_prepare_unique]
    forall R:replica, V:view, O:opnum, C1:command, C2:command.
        honest(R) & prepare_sent(R, V, O, C1) & prepare_sent(R, V, O, C2)
        -> C1 = C2

# 8. Committed implies log entry
invariant [commit_implies_log]
    forall R:replica, V:view, O:opnum, C:command.
        honest(R) & committed(R, V, O, C) ->
        log_entry(R, O, V, C)

# 9. Commit backed by quorum (for leader commits only)
invariant [commit_has_quorum]
    forall R:replica, V:view, O:opnum, C:command.
        honest(R) & is_leader(R, V) & committed(R, V, O, C) ->
        exists Q:quorum. commit_quorum(R, V, O, Q) &
            (forall R2:replica. member(Q, R2) -> (prepare_ok_sent(R2, V, O) | R2 = R))

# 10. commit_sent only originates from honest leaders
invariant [commit_sent_from_honest_leader]
    forall R:replica, V:view, O:opnum.
        commit_sent(R, V, O) -> honest(R) & is_leader(R, V)

################################################################################
# Main Safety Property

# AGREEMENT: Honest replicas never commit conflicting operations
invariant [agreement]
    forall R1:replica, R2:replica, V:view, O:opnum, C1:command, C2:command.
        honest(R1) & honest(R2) &
        committed(R1, V, O, C1) & committed(R2, V, O, C2)
        -> C1 = C2

################################################################################
# Export for Verification

export honest_leader_prepare
export honest_follower_on_prepare
export honest_leader_commit
export honest_follower_on_commit
export byzantine_equivocate_prepare
export byzantine_fake_prepare_ok
