# Kimberlite Independent Security & Compliance Audit

**Audit Date:** January 2026
**Scope:** All 33 workspace crates (kimberlite v0.9.0)
**Focus Areas:** Cryptography, compliance mechanisms, storage integrity, consensus, RBAC/ABAC
**Classification:** Internal — Pre-Production Review

---

## Executive Summary

Kimberlite is a compliance-first, verifiable database targeting regulated industries (healthcare, finance, legal). This audit examined the full source code across 33 workspace crates, verified formal verification claims against implementations, and tested compliance mechanisms against GDPR, HIPAA, PCI-DSS, and SOC 2 requirements.

**Overall Risk Rating: HIGH**

The architecture is excellent — clean layering, functional core/imperative shell, no unsafe code, exceptional assertion density, and a world-class simulation testing framework (VOPR). However, the cryptographic implementation contains **3 critical flaws** and the compliance layer has **2 critical gaps** that must be addressed before production use in regulated environments.

| Severity | Count | Summary |
|----------|-------|---------|
| Critical | 5 | AES-GCM nonce reuse, fake HMAC, non-RFC HKDF, consent not enforced, nonce overflow |
| High | 6 | Missing ZeroizeOnDrop, debug_assert for crypto, export auth gap, erasure proof unverified, SQL interpolation, mutable thresholds |
| Medium | 6 | Unbounded collections, hardcoded business hours, CRC32 limitations, retention not enforced, masking semantics, non-queryable breach events |
| Low/Info | 4 | Missing requester tracking, consent scope matching, formal spec sync, missing proptest for crypto |

**Key Finding:** The `verified/` module in `kimberlite-crypto` references Coq formal proofs, but the Rust implementation deviates from what the proofs assume — the HKDF is simplified (not RFC 5869), nonces are reused in key wrapping, and crypto invariant checks use `debug_assert!()` instead of `assert!()`. The proofs are correct for their model; the implementation does not match the model.

---

## Methodology

1. **Static analysis** of all source code across 33 workspace crates
2. **Formal verification gap analysis** — compared Coq/TLA+ specifications against Rust implementations
3. **Compliance gap analysis** against GDPR Articles 6/7/17/20/25/33, HIPAA §164.312/404, PCI-DSS Requirements 3/7/10, SOC 2
4. **Testing infrastructure review** — VOPR simulation (46 scenarios, 19 invariant checkers), proptest coverage, unit test coverage
5. **Dependency audit** — reviewed cryptographic crate selections and versions
6. **Validation baseline** — ran full test suite and clippy to establish current state

### Validation Baseline (January 2026)

```
cargo nextest run --workspace
  Summary: 2392 tests run: 2392 passed, 2 skipped

cargo clippy --workspace
  Result: 15 warnings in kimberlite-cli (trivially_copy_pass_by_ref, unused matches)
  No warnings in crypto, compliance, kernel, storage, or consensus crates
```

---

## Critical Findings

### C-1: AES-GCM Nonce Reuse in Key Wrapping

**Severity:** CRITICAL
**File:** `crates/kimberlite-crypto/src/verified/key_hierarchy.rs:200-207`
**CWE:** CWE-323 (Reusing a Nonce, Key Pair in Encryption)

**Description:**

The `wrap_dek()` function uses a fixed nonce `[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` for ALL key wrapping operations under the same KEK:

```rust
pub fn wrap_dek(&self, dek: &VerifiedDEK) -> Result<VerifiedWrappedDEK, String> {
    // Use deterministic nonce for key wrapping (non-zero to avoid debug assertion)
    // We use a fixed nonce of 1 for key wrapping operations
    let nonce = [1u8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let ciphertext = VerifiedAesGcm::encrypt(&self.key, &nonce, &dek.key, b"")?;
    Ok(VerifiedWrappedDEK { ciphertext })
}
```

When a tenant has N streams, the same KEK encrypts N different DEKs with the same nonce. AES-GCM nonce reuse under the same key is catastrophic: it allows an attacker to compute XOR of DEK plaintexts and recover the GHASH authentication key, enabling forgery of arbitrary ciphertexts.

**Impact:** Complete compromise of per-tenant encryption hierarchy. An attacker with access to two or more wrapped DEKs for the same tenant can recover all DEK plaintexts and forge new wrapped DEKs.

**Remediation:**
- Use a unique nonce per wrap operation: either a monotonic counter stored alongside the KEK, or `nonce = SHA-256(KEK || DEK_bytes)[0..12]` (synthetic IV approach, see RFC 8452 AES-GCM-SIV)
- Alternatively, switch key wrapping to AES-KW (RFC 3394) or AES-GCM-SIV which is nonce-misuse resistant

---

### C-2: Export "HMAC-SHA256" is Actually SHA-256(key || message)

**Severity:** CRITICAL
**File:** `crates/kimberlite-compliance/src/export.rs:377-382`
**CWE:** CWE-328 (Use of Weak Hash)

**Description:**

The function labeled `hmac_sha256` does not implement HMAC (RFC 2104). It computes simple `SHA-256(key || message)`:

```rust
/// Compute HMAC-SHA256: `SHA256(key || message)`
fn hmac_sha256(key: &[u8], message: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(key);
    hasher.update(message);
    hasher.finalize().to_vec()
}
```

Real HMAC (RFC 2104) is: `H((K ^ opad) || H((K ^ ipad) || m))` with two nested hashing passes and XOR padding. The simplified construction `H(key || message)` is vulnerable to **SHA-256 length extension attacks**: given `SHA-256(key || m1)`, an attacker can compute `SHA-256(key || m1 || padding || m2)` without knowing the key.

The module documentation (line 26-27) and function comments claim "HMAC-SHA256" — this is inaccurate and misleading for compliance auditors reviewing the system.

**Impact:** Export signatures can be forged via length extension. Compliance documentation claiming HMAC-SHA256 is factually incorrect — a regulatory auditor would flag this as a material misrepresentation.

**Remediation:**
- Add the `hmac` crate as a workspace dependency
- Replace the implementation with: `Hmac::<Sha256>::new_from_slice(key).update(message).finalize()`
- Update documentation to accurately describe the signing scheme

---

### C-3: Simplified HKDF — Not RFC 5869 Compliant

**Severity:** CRITICAL
**File:** `crates/kimberlite-crypto/src/verified/key_hierarchy.rs:148-156`
**CWE:** CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)

**Description:**

The key derivation function labeled "HKDF" is a single-pass SHA-256 hash, not RFC 5869 HKDF:

```rust
/// HKDF key derivation (simplified for this implementation)
fn hkdf_derive(ikm: &[u8; 32], salt: &[u8], info: &[u8]) -> [u8; 32] {
    // Simplified HKDF: SHA-256(ikm || salt || info)
    // Production should use proper HKDF from `hkdf` crate
    let mut hasher = Sha256::new();
    hasher.update(ikm);
    hasher.update(salt);
    hasher.update(info);
    hasher.finalize().into()
}
```

The comment on line 150 explicitly acknowledges this: *"Production should use proper HKDF from `hkdf` crate"*.

RFC 5869 HKDF has two phases:
1. **Extract:** `PRK = HMAC-Hash(salt, IKM)` — concentrates entropy
2. **Expand:** `OKM = HMAC-Hash(PRK, info || counter)` — derives keys

The simplified construction `SHA-256(ikm || salt || info)` skips the extract phase entirely, reducing key separation guarantees. The entire key hierarchy (Master -> KEK -> DEK) relies on this function for tenant isolation and stream isolation.

The Coq proofs (`specs/coq/KeyHierarchy.v`) assume HKDF injectivity as an axiom (see `TENANT_ISOLATION_CERT` at line 30: `assumption_count: 1 // HKDF injectivity`). This assumption holds for proper HKDF but may not hold for the simplified construction, meaning the formal proofs do not apply to the actual implementation.

**Impact:** Key hierarchy may not provide the isolation guarantees claimed by the formal proofs. While the simplified construction likely provides adequate separation in practice (SHA-256 collision resistance), it does not meet the specification the proofs assume.

**Remediation:**
- Add the `hkdf` crate as a workspace dependency
- Replace with: `Hkdf::<Sha256>::new(Some(salt), ikm).expand(info, &mut okm)`
- This closes the gap between the Coq proof model and the implementation

---

### C-4: Consent Not Enforced at Data Access Boundary

**Severity:** CRITICAL (Compliance)
**Files:** `crates/kimberlite/src/tenant.rs` (lines 169, 255, 336)
**Regulation:** GDPR Articles 6, 7, 25

**Description:**

The `ConsentTracker` exists in `kimberlite-compliance` and is wired into `KimberliteInner`, with `validate_consent()`, `grant_consent()`, and `withdraw_consent()` exposed via `TenantHandle`. However, the core data access methods — `append()`, `query()`, and `read_events()` — never call `validate_consent()`:

- `append()` (line 169): Directly submits command without consent check
- `query()` (line 255): Directly queries projection store without consent check
- `read_events()` (line 336): Directly reads log without consent check

Consent validation is entirely opt-in at the application layer. For a database that positions itself as "compliance-first," this is a significant gap. GDPR Article 25 ("Data protection by design and by default") expects consent to be enforced by the system, not delegated to application developers.

**Impact:** Applications built on Kimberlite can access personal data without valid consent, undermining the "compliance-first" value proposition. A GDPR auditor would note that consent is available but not enforced.

**Remediation:**
- Add a configurable consent enforcement mode to tenant configuration (e.g., `ConsentMode::Required`, `ConsentMode::Optional`, `ConsentMode::Disabled`)
- When `Required`, intercept `append()`, `query()`, and `read_events()` with `validate_consent()` calls
- Default to `Required` for tenants marked as processing personal data
- Log consent validation results to the audit trail

---

### C-5: Nonce Position Overflow Produces All-Zero Nonce

**Severity:** CRITICAL
**File:** `crates/kimberlite-crypto/src/verified/aes_gcm.rs:183-189`
**CWE:** CWE-190 (Integer Overflow)

**Description:**

The `nonce_from_position()` function adds 1 to the position to avoid all-zero nonces:

```rust
pub fn nonce_from_position(position: u64) -> [u8; 12] {
    let mut nonce = [0u8; 12];
    // Add 1 to avoid all-zero nonce at position 0
    nonce[0..8].copy_from_slice(&(position + 1).to_le_bytes());
    nonce
}
```

At `position = u64::MAX (18446744073709551615)`:
- In **debug** builds: panics due to overflow check (Rust default)
- In **release** builds: wraps to 0, producing `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` — an all-zero nonce

The all-zero nonce check at line 122 (`debug_assert_ne!(nonce, &[0u8; 12])`) is also stripped in release mode (see finding H-2), so both protections are absent in production.

While reaching `u64::MAX` positions is practically unlikely (would require exabytes of data), the code's own design shows awareness of the all-zero nonce hazard — the +1 offset exists specifically to prevent it. The fix should be complete.

**Impact:** Theoretical all-zero nonce in release builds at u64::MAX, which would collide with any other stream using the same key at the same special position.

**Remediation:**
- Use `position.checked_add(1).expect("nonce position overflow")` to make the overflow a hard error in all build modes
- Or restrict position to `u64::MAX - 1` with a precondition assertion

---

## High Severity Findings

### H-1: No ZeroizeOnDrop on Verified Key Types

**Severity:** HIGH
**File:** `crates/kimberlite-crypto/src/verified/key_hierarchy.rs:76-95`
**CWE:** CWE-244 (Improper Clearing of Heap Memory)

**Description:**

The verified key types (`VerifiedMasterKey`, `VerifiedKEK`, `VerifiedDEK`) store raw key material in `[u8; 32]` arrays but do not implement `ZeroizeOnDrop`:

```rust
#[derive(Clone)]
pub struct VerifiedMasterKey {
    key: [u8; 32],
}

#[derive(Clone)]
pub struct VerifiedKEK {
    key: [u8; 32],
}

#[derive(Clone)]
pub struct VerifiedDEK {
    key: [u8; 32],
}
```

The non-verified counterparts in the `encryption` module DO implement `ZeroizeOnDrop` — this is an inconsistency within the same crate. Without `ZeroizeOnDrop`, key material persists in memory after the struct is dropped, accessible via memory dumps, core dumps, or swap files.

**Remediation:**
- Add `zeroize` dependency to the crate (if not already present)
- Add `#[derive(Zeroize, ZeroizeOnDrop)]` to all three key types
- Remove `Clone` derive from `VerifiedMasterKey` (master keys should not be casually cloned)

---

### H-2: Debug Assertions for Cryptographic Invariants (Should Be Production)

**Severity:** HIGH
**Files:** `crates/kimberlite-crypto/src/verified/aes_gcm.rs:119-122`, `crates/kimberlite-crypto/src/verified/key_hierarchy.rs:109,119`
**CWE:** CWE-617 (Reachable Assertion)

**Description:**

Critical cryptographic invariant checks use `debug_assert!()` instead of `assert!()`:

```rust
// aes_gcm.rs:119-122
debug_assert_ne!(key, &[0u8; 32], "AES-256 key is all zeros (degenerate key)");
debug_assert_ne!(nonce, &[0u8; 12], "GCM nonce is all zeros (weak nonce)");

// key_hierarchy.rs:109
debug_assert_ne!(key, [0u8; 32], "Master key is all zeros (degenerate)");

// key_hierarchy.rs:119
debug_assert_ne!(bytes, [0u8; 32], "Master key is all zeros");
```

The project's own `CLAUDE.md` (section "Assertion Density") explicitly mandates:
> *Use `assert!()` for cryptographic invariants, consensus safety, state machine correctness, and compliance-critical properties*

The v0.2.0 changelog documents promoting 25 cryptographic assertions to production. These 4 assertions in the `verified/` module were apparently missed.

**Impact:** All-zero key and nonce checks are stripped from release builds, allowing degenerate keys to be used silently.

**Remediation:**
- Change all `debug_assert_ne!` to `assert_ne!` in `verified/aes_gcm.rs` and `verified/key_hierarchy.rs`
- Add corresponding `#[should_panic]` tests per the project's assertion testing convention

---

### H-3: Export Missing Authorization & Requester Tracking

**Severity:** HIGH
**File:** `crates/kimberlite-compliance/src/export.rs:172-177`
**Regulation:** GDPR Article 15, SOC 2 CC6.1

**Description:**

`export_subject_data()` accepts any `subject_id` string without authorization. There is no check that the caller is authorized to export the specified subject's data. Additionally, the `ExportAuditRecord` (lines 126-142) has no `requester_id` field — it records *what* was exported and *when*, but not *who* triggered the export.

```rust
pub fn export_subject_data(
    &mut self,
    subject_id: &str,         // No authorization check
    records: &[ExportRecord],
    format: ExportFormat,
) -> Result<PortabilityExport> {
```

**Impact:** Any code path with access to the `ExportEngine` can export any subject's data. The audit trail cannot answer "who exported this data?" — a question regulators routinely ask.

**Remediation:**
- Add a `requester: &CallerContext` parameter to `export_subject_data()`
- Add `requester_id: String` field to `ExportAuditRecord`
- Validate that the requester is authorized (either the subject themselves, or an admin role)

---

### H-4: Erasure Proof Accepted Without Verification

**Severity:** HIGH
**File:** `crates/kimberlite-compliance/src/erasure.rs:367-411`
**Regulation:** GDPR Article 17

**Description:**

The `complete_erasure()` function accepts an `erasure_proof: Hash` parameter and stores it directly in the audit record without verification:

```rust
pub fn complete_erasure(
    &mut self,
    request_id: Uuid,
    erasure_proof: Hash,      // Stored but never verified
) -> Result<ErasureAuditRecord> {
    // ... status checks ...
    request.status = ErasureStatus::Complete { ... };
    let audit_record = ErasureAuditRecord {
        // ...
        erasure_proof: Some(erasure_proof),  // Blind trust
    };
    self.completed.push(audit_record.clone());
    Ok(audit_record)
}
```

A caller can pass an arbitrary hash as "proof" of erasure without actually erasing any data. The system has no way to verify that the proof corresponds to the records that were supposed to be erased.

**Impact:** Erasure compliance can be faked by passing garbage proof hashes. In a regulatory audit, the erasure proof would not withstand scrutiny.

**Remediation:**
- Compute expected erasure proof internally: `SHA-256(request_id || sorted_record_ids || erased_count)`
- Compare the provided proof against the expected proof before accepting
- Or compute the proof internally and remove it as a caller-provided parameter

---

### H-5: SQL Row Filter Value Not Parameterized

**Severity:** HIGH
**File:** `crates/kimberlite-rbac/src/enforcement.rs:182`
**CWE:** CWE-89 (SQL Injection)

**Description:**

The `generate_where_clause()` method constructs SQL via string interpolation:

```rust
format!("{} {op} {}", f.column, f.value)
```

The `f.value` is directly interpolated into the SQL string. Currently this is safe because values originate from `StandardPolicies` (hardcoded policy definitions). However, the `RbacFilter` API is public (`pub fn generate_where_clause`), and the `RowFilter` struct's fields are public, allowing external code to construct filters with arbitrary values.

**Impact:** Currently safe (internal use only), but the API surface permits SQL injection if used with untrusted input. This is a latent vulnerability.

**Remediation:**
- Validate that `f.value` contains only safe literal values (numbers, quoted strings, `NULL`)
- Or refactor to a parameterized query builder pattern
- Or make `RowFilter` construction private to the RBAC module

---

### H-6: Breach Thresholds Mutable Without Audit Trail

**Severity:** HIGH
**File:** `crates/kimberlite-compliance/src/breach.rs:120-141`
**Regulation:** SOC 2 CC7.2

**Description:**

`BreachThresholds` has all public fields:

```rust
pub struct BreachThresholds {
    pub mass_export_records: u64,
    pub denied_attempts_window: u64,
    pub query_volume_multiplier: f64,
    pub export_bytes_threshold: u64,
}
```

An administrator (or compromised code) could raise the thresholds to suppress breach detection without leaving any audit trail. For example, setting `mass_export_records: u64::MAX` would effectively disable the mass export indicator.

**Impact:** Breach detection can be silently disabled by threshold manipulation, undermining the entire breach notification mechanism.

**Remediation:**
- Make fields private with controlled setters that log changes to the audit trail
- Or make `BreachThresholds` immutable after construction (builder pattern with `freeze()`)
- Log all threshold changes as audit events

---

## Medium Severity Findings

### M-1: Breach Events Not Queryable by Subject

**Severity:** MEDIUM
**File:** `crates/kimberlite-compliance/src/audit.rs`
**Regulation:** GDPR Article 15 (Right of Access)

**Description:**

The audit log's `matches_subject()` filtering does not cover breach-related events. When a data subject requests their records (GDPR Article 15), breach events affecting them are not returned. Data subjects have the right to know if their data was involved in a breach.

**Remediation:** Extend `matches_subject()` to include breach events that reference the subject's data.

---

### M-2: Business Hours Hardcoded to 9-17 UTC

**Severity:** MEDIUM
**File:** `crates/kimberlite-compliance/src/breach.rs:32-35`

**Description:**

The `AfterHoursAccess` breach indicator uses hardcoded business hours (9:00-17:00 UTC). This is inappropriate for global deployments — a legitimate access at 10:00 JST would be flagged as after-hours (01:00 UTC).

**Remediation:** Make business hours configurable per-tenant with timezone support.

---

### M-3: Unbounded Growth in Compliance Vec Collections

**Severity:** MEDIUM
**Files:** `crates/kimberlite-compliance/src/audit.rs`, `export.rs`, `erasure.rs`

**Description:**

All compliance engines store records in unbounded `Vec<T>` collections:
- `AuditLog.entries: Vec<AuditEntry>`
- `ExportEngine.exports: Vec<PortabilityExport>`
- `ExportEngine.audit_trail: Vec<ExportAuditRecord>`
- `ErasureEngine.completed: Vec<ErasureAuditRecord>`

In a long-running production system processing millions of compliance events, these vectors will grow without bound, eventually exhausting memory.

**Remediation:** Implement bounded storage with configurable limits and archival/eviction policies.

---

### M-4: CRC32 for Storage Integrity — Adequate for Error Detection, Not Tamper Resistance

**Severity:** MEDIUM
**File:** `crates/kimberlite-storage/`

**Description:**

The append-only log uses CRC32 checksums for integrity verification. CRC32 is excellent for detecting accidental corruption (bit flips, partial writes) but provides no tamper resistance — an attacker who modifies a record can trivially recompute a valid CRC32.

The hash chain (SHA-256) provides tamper evidence at the chain level, but individual record integrity relies on CRC32 alone. This is a known design trade-off (CRC32 is fast; SHA-256 per-record would be slow).

**Remediation:** Document this as a known limitation. For high-integrity deployments, consider optional per-record HMAC or Merkle tree verification.

---

### M-5: Retention Engine Returns Recommendations, Not Enforcement

**Severity:** MEDIUM
**File:** `crates/kimberlite-compliance/src/retention.rs`

**Description:**

The retention engine identifies records that should be purged based on retention policies but returns recommendations rather than performing actual deletion. This is by design (pure functional approach), but it means retention is not self-enforcing — an operator must act on the recommendations.

**Remediation:** Document the operational requirement for a retention enforcement job. Consider adding an optional auto-enforcement mode.

---

### M-6: Masking Policy "applies_to_roles" Empty = Apply to All

**Severity:** MEDIUM
**File:** `crates/kimberlite-rbac/src/masking.rs`

**Description:**

When a `MaskingPolicy` has an empty `applies_to_roles` Vec, it applies to ALL roles. This is confusing — most systems interpret "empty set" as "applies to none." An administrator who forgets to specify roles would inadvertently mask data for everyone, including admins.

**Remediation:** Either:
- Change semantics: empty `applies_to_roles` = applies to no one (require explicit role listing)
- Or use `Option<Vec<Role>>`: `None` = all roles, `Some(vec![])` = no roles

---

## Low Severity / Informational Findings

### L-1: Export Audit Record Missing requester_id

**Severity:** LOW
**File:** `crates/kimberlite-compliance/src/export.rs:126-142`

**Description:** `ExportAuditRecord` tracks what was exported but not who triggered the export. Related to H-3 but listed separately as an information gap.

---

### L-2: ConsentScope Exact-Match Only

**Severity:** LOW
**File:** `crates/kimberlite-compliance/src/consent.rs`

**Description:** Consent validation uses exact scope matching. A consent grant for `ContactInfo` does not satisfy a check for `AllData`. Hierarchical scope resolution (where broader consent subsumes narrower) is not implemented.

---

### L-3: Formal Specification Alignment Not Automated in CI

**Severity:** LOW
**Files:** `specs/coq/`, `specs/tla+/`, `.github/`

**Description:** Coq and TLA+ specifications exist and are verifiable, but there is no CI step that automatically verifies them against the Rust implementation. The `verified/` module references proof certificates with `verified_at` timestamps but these are static constants — there is no runtime or build-time check that the proofs are still valid for the current code.

**Remediation:** Add CI steps that:
1. Check-compile the Coq proofs
2. Run TLA+ model checking
3. Generate a proof manifest that can be compared against the embedded certificates

---

### L-4: Property-Based Tests Absent for Crypto Functions

**Severity:** LOW
**File:** `crates/kimberlite-crypto/`

**Description:** The `kimberlite-crypto` crate has thorough unit tests but does not use `proptest` for property-based testing. Other crates in the workspace use `proptest` extensively. Property-based tests for crypto would verify invariants like:
- `decrypt(encrypt(plaintext)) == plaintext` for arbitrary plaintext
- `nonce_from_position(a) != nonce_from_position(b)` for all `a != b`
- Key derivation produces different keys for different inputs

---

## Compliance Gap Analysis

### GDPR Compliance Matrix

| Article | Requirement | Status | Gap |
|---------|-------------|--------|-----|
| Art. 6 | Lawful basis for processing | **PARTIAL** | Consent exists but not enforced at kernel level (C-4) |
| Art. 7 | Conditions for consent | **PARTIAL** | Opt-in only; no default-on enforcement mode |
| Art. 17 | Right to erasure | **GOOD** | Engine exists with 30-day deadlines, exemptions; proof not verified (H-4) |
| Art. 20 | Data portability | **PARTIAL** | Export works but HMAC is not real HMAC (C-2); missing requester tracking (H-3) |
| Art. 25 | Privacy by design/default | **PARTIAL** | Consent should be default-on for personal data tenants (C-4) |
| Art. 33 | Breach notification (72h) | **GOOD** | 72h deadline enforced; 6 indicators; severity classification |
| Art. 35 | DPIA | N/A | Not in scope for database layer |

### HIPAA Compliance Matrix

| Section | Requirement | Status | Gap |
|---------|-------------|--------|-----|
| §164.312(a) | Access control | **GOOD** | RBAC with 4 roles (Admin, Analyst, User, Auditor) |
| §164.312(c) | Integrity controls | **PARTIAL** | CRC32 for error detection; hash chain for tamper evidence; but individual records not tamper-resistant (M-4) |
| §164.312(d) | Person/entity authentication | **GOOD** | Ed25519 digital signatures with `verify_strict()` |
| §164.312(e) | Transmission security | **GOOD** | AES-256-GCM encryption (implementation needs fixes per C-1, C-3, C-5) |
| §164.404 | Breach notification | **GOOD** | 72h enforcement, 6 breach indicators, severity classification |

### PCI-DSS Compliance Matrix

| Req | Description | Status | Gap |
|-----|-------------|--------|-----|
| 3 | Protect stored cardholder data | **FAIL** | HKDF not RFC-compliant (C-3); AES-GCM nonce reuse (C-1); nonce overflow (C-5) |
| 7 | Restrict access by business need-to-know | **GOOD** | RBAC with column/row filtering; ABAC with HIPAA/FedRAMP/PCI policies |
| 10 | Track and monitor all access | **PARTIAL** | Audit log exists (13 action types) but unbounded (M-3); missing requester on exports (H-3) |

### SOC 2 Trust Services Criteria

| Criteria | Status | Gap |
|----------|--------|-----|
| CC6.1 (Logical access) | **GOOD** | RBAC + ABAC + masking |
| CC6.3 (Access removal) | **GOOD** | Consent withdrawal, role-based restrictions |
| CC7.2 (Monitoring) | **PARTIAL** | Breach thresholds mutable without audit (H-6) |
| CC7.3 (Incident management) | **GOOD** | Breach detection, 72h notification, severity classification |
| CC8.1 (Change management) | N/A | Infrastructure concern, not database layer |

---

## Positive Findings (Strengths)

The following aspects of Kimberlite's implementation are notable strengths:

1. **No unsafe code** — Workspace-wide `#[deny(unsafe_code)]` lint. This is rare for a database system and eliminates entire classes of memory safety bugs.

2. **Exceptional assertion density** — Paired preconditions and postconditions throughout the codebase, with 38 critical assertions promoted to production enforcement in v0.2.0. Assertion testing coverage with `#[should_panic]` tests.

3. **Formal verification infrastructure** — Coq specifications for crypto primitives, TLA+ for consensus, Alloy for data model, Ivy for protocol verification. While implementation-proof alignment needs work (C-3, L-3), the investment in formal methods is significant.

4. **VOPR simulation testing** — 46 test scenarios, 19 invariant checkers, 100% deterministic reproduction, 85k-167k sims/sec. This is Antithesis-grade testing without the hypervisor — industry-leading for an open source database.

5. **Pure functional kernel (FCIS)** — Commands produce (State, Effects) with no IO in the core. This eliminates entire classes of IO-related state bugs and makes the system dramatically easier to test and reason about.

6. **Ed25519 with verify_strict()** — Correctly rejects non-canonical signatures. Many implementations use `verify()` which accepts malleable signatures.

7. **ZeroizeOnDrop on encryption keys** — The non-verified encryption module properly zeros key material on drop. (The verified module is missing this — see H-1.)

8. **Hash chain integrity** — Append-only log with SHA-256 chaining provides tamper evidence at the chain level. Combined with CRC32 for error detection, this is a sound two-layer integrity approach.

9. **Comprehensive error types** — `thiserror` throughout with rich context. No `unwrap()` in library code. Error handling follows Rust best practices.

10. **Clean architecture** — 33 focused crates with clear layering and dependency boundaries. The crate graph is well-organized with minimal circular dependencies.

---

## Remediation Roadmap

### Immediate — Block v1.0.0 Release

These must be fixed before any production or compliance-certified deployment:

| Priority | Finding | Fix | Estimated Effort |
|----------|---------|-----|-----------------|
| P0 | C-1: AES-GCM nonce reuse | Unique nonce per wrap (counter or synthetic IV) | Small |
| P0 | C-2: Fake HMAC | Use `hmac` crate, implement RFC 2104 | Small |
| P0 | C-3: Simplified HKDF | Use `hkdf` crate, implement RFC 5869 | Small |
| P0 | C-5: Nonce overflow | Use `checked_add()` with error | Trivial |
| P0 | H-2: debug_assert for crypto | Change to `assert!()`, add `#[should_panic]` tests | Small |
| P0 | H-1: Missing ZeroizeOnDrop | Add `#[derive(Zeroize, ZeroizeOnDrop)]` | Trivial |

### Before Compliance Certification

These should be fixed before submitting for GDPR, HIPAA, or PCI-DSS certification:

| Priority | Finding | Fix | Estimated Effort |
|----------|---------|-----|-----------------|
| P1 | C-4: Consent not enforced | Add configurable consent enforcement mode | Medium |
| P1 | H-3: Export auth gap | Add requester context, authorization check | Small |
| P1 | H-4: Erasure proof unverified | Compute and compare expected proof | Small |
| P1 | H-5: SQL interpolation | Validate/parameterize filter values | Small |
| P1 | H-6: Mutable thresholds | Immutable thresholds or audited changes | Small |

### Next Release

| Priority | Finding | Fix | Estimated Effort |
|----------|---------|-----|-----------------|
| P2 | M-1: Non-queryable breach events | Extend `matches_subject()` | Small |
| P2 | M-2: Hardcoded business hours | Configurable per-tenant with timezone | Small |
| P2 | M-3: Unbounded collections | Bounded storage with eviction/archival | Medium |
| P2 | M-5: Retention not enforced | Optional auto-enforcement mode | Medium |
| P2 | M-6: Masking semantics | Clarify empty-set behavior | Trivial |
| P2 | L-3: Formal spec CI | Automated proof checking in CI | Medium |
| P2 | L-4: Crypto proptest | Add property-based tests for crypto | Small |

---

## Appendix A: Test Baseline

```
$ cargo nextest run --workspace
Summary: 2392 tests run, 2392 passed, 2 skipped
Duration: 7.044s (wall), 22.510s (total)

$ cargo clippy --workspace
Warnings: 15 (all in kimberlite-cli, trivially_copy_pass_by_ref)
Errors: 0
Crypto/compliance/kernel/storage crates: clean
```

## Appendix B: Files Examined

Key files examined during this audit (not exhaustive):

| File | Findings |
|------|----------|
| `crates/kimberlite-crypto/src/verified/key_hierarchy.rs` | C-1, C-3, H-1, H-2 |
| `crates/kimberlite-crypto/src/verified/aes_gcm.rs` | C-5, H-2 |
| `crates/kimberlite-compliance/src/export.rs` | C-2, H-3, L-1 |
| `crates/kimberlite-compliance/src/erasure.rs` | H-4 |
| `crates/kimberlite-compliance/src/breach.rs` | H-6, M-2 |
| `crates/kimberlite-compliance/src/audit.rs` | M-1, M-3 |
| `crates/kimberlite-compliance/src/retention.rs` | M-5 |
| `crates/kimberlite-rbac/src/enforcement.rs` | H-5 |
| `crates/kimberlite-rbac/src/masking.rs` | M-6 |
| `crates/kimberlite/src/tenant.rs` | C-4 |
| `crates/kimberlite-storage/` | M-4 |

## Appendix C: Cryptographic Dependencies

| Crate | Version | Usage | Assessment |
|-------|---------|-------|------------|
| `aes-gcm` | workspace | AES-256-GCM encryption | Good choice; correctly used except nonce management |
| `sha2` | workspace | SHA-256 hashing | Good choice |
| `ed25519-dalek` | workspace | Digital signatures | Good choice; uses `verify_strict()` |
| `blake3` | workspace | Internal hashing | Good choice for non-compliance paths |
| `rand` | workspace | Randomness | Uses `OsRng` — correct |
| `hkdf` | **NOT PRESENT** | Key derivation | **Must add** — currently using simplified SHA-256 |
| `hmac` | **NOT PRESENT** | Export signing | **Must add** — currently using SHA-256(key\|\|msg) |
| `zeroize` | workspace | Key cleanup | Present but not used on verified key types |

---

*This audit was conducted as an internal pre-production review. All findings are based on source code analysis as of the January 2026 main branch (commit 76b3723). No penetration testing or runtime analysis was performed.*
